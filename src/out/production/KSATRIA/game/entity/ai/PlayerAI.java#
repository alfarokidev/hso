package game.entity.ai;

import game.entity.base.LivingEntity;
import game.entity.monster.MonsterEntity;
import game.entity.player.PlayerEntity;
import game.skill.SkillEntity;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import model.skill.LvSkill;
import model.skill.Skill;

import java.util.ArrayList;
import java.util.List;

@Slf4j
@Getter
public class PlayerAI extends BaseAI {

    private static final int LIMIT_RANGE = 300;
    private static final int MELEE_RANGE = 48;
    private static final long TARGET_SEARCH_INTERVAL = 1200;

    private long lastRepathTime;
    private static final long REPATH_INTERVAL = 500;

    private long lastTargetSearch;
    private SkillEntity selectedSkill;

    public PlayerAI(PlayerEntity player) {
        super(player);
        player.setMoveSpeed(24);
        log.info("===== PlayerAI initialized: moveSpeed={}, LIMIT_RANGE={} =====",
                player.getMoveSpeed(), LIMIT_RANGE);
    }

    @Override
    public void update(long deltaTime) {
        checkPotions();
        updateMovement(deltaTime);

        switch (state) {
            case IDLE -> updateIdle();
            case MOVING -> updateMoving();
            case ATTACK -> updateCombat();
        }
    }

    private void updateIdle() {
        long now = System.currentTimeMillis();
        if (now - lastTargetSearch < TARGET_SEARCH_INTERVAL) return;

        lastTargetSearch = now;

        log.debug("===== SEARCHING FOR TARGET =====");

        LivingEntity target = findNearestMonster();

        if (target != null) {
            log.debug("===== FOUND TARGET: {} at distance {} =====",
                    target.getClass().getSimpleName(), entity.distanceTo(target));
            log.debug("Target position: ({},{})", target.getPosition().getX(), target.getPosition().getY());

            setTarget(target);
            selectedSkill = findBestSkill();

            log.debug("===== Selected skill: {} =====",
                    selectedSkill != null ? selectedSkill.getSkillId() : "NONE (melee)");

            setState(AIState.MOVING);
        } else {
            log.debug("No target found in range {}", LIMIT_RANGE);
        }
    }

    private void updateMoving() {
        if (isInvalidTarget(target)) {
            reset();
            log.debug("INVALID TARGET , RESET");
            return;
        }

        int attackRange = getSkillRange(selectedSkill);
        int distance = entity.distanceTo(target);

        if (distance <= attackRange) {
            stopMove();
            setState(AIState.ATTACK);
            return;
        }

        long now = System.currentTimeMillis();

        if (now - lastRepathTime > REPATH_INTERVAL) {
            lastRepathTime = now;

            stopMove();

            moveToEntity(target, attackRange);
        }
    }


    private void updateCombat() {
        if (isInvalidTarget(target)) {
            log.debug("===== Combat: Invalid target, resetting =====");
            reset();
            return;
        }

        int attackRange = getSkillRange(selectedSkill);
        int distance = entity.distanceTo(target);

        log.debug("===== COMBAT: distance={}, attackRange={} =====", distance, attackRange);

        if (distance > attackRange) {
            log.debug("===== Target out of range, switching to MOVING =====");
            setState(AIState.MOVING);
            return;
        }


        if (selectedSkill != null) {

            if (!selectedSkill.isOnCooldown()) {
                useSkill(selectedSkill);
            } else {
                // skill cooling down → do nothing this tick
                log.debug("Skill {} on cooldown, waiting...", selectedSkill.getSkillId());
            }

        } else {
            // no skill → use normal attack with global cooldown

            entity.attack(target);

        }
    }

    private void checkPotions() {
        if (entity.getHpPercent() < 50) {
            log.debug("Using HP potion: {}% -> 100%", entity.getHpPercent());
            entity.restoreHp(entity.getMaxHp() - entity.getHp());
        }
        if (entity.getMpPercent() < 50) {
            log.debug("Using MP potion: {}% -> 100%", entity.getMpPercent());
            entity.restoreMp(entity.getMaxMp() - entity.getMp());
        }
    }

    private boolean isInvalidTarget(LivingEntity target) {

        // 1. NULL
        if (target == null) {
            log.debug("Target validation failed: target is null");
            return true;
        }

        // 2. DEAD
        if (target.isDead()) {
            log.debug("Target validation failed: target is dead");
            return true;
        }

        // 3. ZONE
        if (entity.getZone() != target.getZone()) {
            log.debug("Target validation failed: different zones");
            return true;
        }

        // 4. DISTANCE
        int distance = entity.distanceTo(target);
        if (distance > LIMIT_RANGE) {
            log.debug("Target validation failed: distance {} > LIMIT_RANGE {}", distance, LIMIT_RANGE);
            return true;
        }

        return false;
    }


    private LivingEntity findNearestMonster() {
        if (entity.getZone() == null) {
            log.error("===== ZONE IS NULL! =====");
            return null;
        }

        if (entity.getZone().getMonsters() == null) {
            log.error("===== ZONE.getMonsters() IS NULL! =====");
            return null;
        }

        MonsterEntity nearest = null;
        int nearestDist = Integer.MAX_VALUE;

        for (MonsterEntity mob : entity.getZone().getMonstersInRadius(entity, LIMIT_RANGE)) {

            if (mob.isDead()) {
                log.trace("Monster is dead");
                continue;
            }

            if (mob.getLivingTimeInSecond() <= 2) {
                continue;
            }

            int dist = entity.distanceTo(mob);
            if (dist < nearestDist) {
                nearest = mob;
                nearestDist = dist;
            }
        }

        return nearest;
    }

    private SkillEntity findBestSkill() {
        SkillEntity best = null;
        int bestPriority = -1;

        for (SkillEntity skill : entity.getSkillData().values()) {
            if (skill == null || skill.getType() != 0) continue;

            if (skill.getCurrentLevel() <= 0 || skill.isOnCooldown()) continue;

            LvSkill lv = skill.getCurrentLevelData();
            if (lv == null) continue;

            int priority = skill.getCurrentLevel();
            if (priority > bestPriority) {
                bestPriority = priority;
                best = skill;
            }
        }

        log.debug("findBestSkill: found={}, priority={}",
                best != null ? best.getSkillId() : "NONE", bestPriority);

        return best;
    }

    private void useSkill(SkillEntity skill) {
        LvSkill lv = skill.getCurrentLevelData();
        if (lv == null || target == null) return;

        if (lv.targetCount > 1) {
            int atkRange = skill.getSkillData().attackRange;
            List<LivingEntity> targets = findAoETargets(target, lv.targetCount, atkRange);
            if (!targets.isEmpty()) {

                entity.useSkillAoE(skill.getSkillId(), target, targets);
            }
        } else {

            entity.useSkill(skill.getSkillId(), target);
        }

        selectedSkill = findBestSkill();
    }

    private List<LivingEntity> findAoETargets(LivingEntity target, int maxTargets, int radius) {
        List<LivingEntity> targets = new ArrayList<>();

        for (MonsterEntity mob : entity.getZone().getMonstersInRadius(target, radius)) {
            if (mob != null && !mob.isDead() && entity.distanceTo(mob) <= radius) {
                targets.add(mob);
                if (targets.size() >= maxTargets) return targets;
            }
        }

        if (entity.getTypePK() != -1) {
            for (PlayerEntity p : entity.getZone().getPlayers()) {
                if (p != null && !p.isDead() && p != entity &&
                        p.getTypePK() != entity.getTypePK() &&
                        entity.distanceTo(p) <= radius) {
                    targets.add(p);
                    if (targets.size() >= maxTargets) return targets;
                }
            }
        }


        return targets;
    }

    private int getSkillRange(SkillEntity skill) {
        if (skill == null) return MELEE_RANGE;
        Skill lv = skill.getSkillData();
        return lv != null && lv.attackRange > 0 ? lv.attackRange : MELEE_RANGE;
    }
}